---
title: "Parcial 1 - Simulación Digital - H1"
author: "Prof. David Romo Bucheli"
output:
  html_document:
    df_print: paged
---

Desarrollado por: Daniel David Delgado Cervantes 2182066

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Parcial 1 - Simulación Digital

Desarrolle primero un análisis detallado del problema explicando el enfoque de su simulación. Puede incluir en el análisis pseudocódigo y/o diagramas de flujo para cada una de las funciones necesarias (Como evidencia incluir un archivo pdf con la imagen del pseudocódigo o en diagrama de flujo implementado). Posteriormente realice la implementación en R (Evidencia: el archivo del notebook RMD correspondiente. Asegúrese de incluir la explicación en el archivo RMD. Incluir solamente el código se evaluará como una entrega incompleta). Para generar números aleatorios con distribución uniforme continua puede utilizar la función runif. Solamente se permite la utilización de esa función, de las librerías de generación de números aleatorios de R.

**Problema 1.**
Utilizando el método de integración Monte Carlo, evalúe la siguiente integral:

$$\int_0^1\int_0^1\int_0^1\int_0^1 \lfloor x_1+x_2+x_3+x_4\rfloor dx_1dx_2dx_3dx_4$$
Recuerde que $\lfloor y \rfloor$ equivale a tener el valor entero del número y. Utilizando varias veces el proceso de integración, asegúrese de que el número de iteraciones utilizada para la estimación sea menos de 100 y además que la muestra tenga una desviación estandar muestral menor o igual a 0.01. (Almacene el resultado de la integral en la variable `ans.PIa` y el valor de la desviación estandar en `ans.PIb`)

#### Desarrollo

Lo primero que necesitamos definir para el desarrollo del ejercicio, está en el definir como será la ecuación que usaremos para poder realizar la aproximación. Ya teniendo la integral 

```{r}

ests <- c()
sz <- 10000

for (i in 1:99) {
    uX1 <- runif(sz, min = 0, max = 1)
    uX2 <- runif(sz, min = 0, max = 1)
    uX3 <- runif(sz, min = 0, max = 1)
    uX4 <- runif(sz, min = 0, max = 1)
    res <- sum(floor(uX1 + uX2 + uX3 + uX4)) / sz
    ests <- c(ests, res)
}

mn <- mean(ests)
std <- sd(ests)

print(mn)
print(std)
```

```{r}
ans.pIa <- 0
ans.pIb <- 0
```


```
. = ottr::check("tests/p2.R")
```

**Problema 2.**
La eliminatoria sudamericana Qatar 2022 es un torneo internacional en el cual participan 10 selecciones de fútbol de países sudamericanos: Argentina, Bolivia, Brasil, Chile, Colombia, Ecuador, Paraguay, Perú, Uruguay, y Venezuela, en un sistema todos contra todos con partidas de ida y vuelta. Los primeros 4 equipos clasificarán directamente a la copa mundial Qatar 2022, mientras que el equipo que logre la 5ta posición irá a repechaje internacional (Ver más detalles en el archivo adjunto).


Realice una implementación que al menos contenga las siguientes funciones:

- inicializar_simulacion(). La función debe retornar un dataframe con los puntos actuales que tiene cada una de las selecciones

- prob_partido(ELOlocal, ELOvisitante). La función debe retornar un vector con las probabilidades de victoria, empate y derrota para un partido, en la cual el equipo local tiene fuerza de juego ELOlocal, y el visitante ELOvisitante

- simular_partido(ELOlocal, ELOvisitante): La función debe retornar resultado de la simulación de un partido

- extraer_partidos(): La función debe retornar un dataframe con la información de los partidos por jugar

- extraer_ELO(): La función debe retornar dataframe con información del ELO de los equipos

- simular_torneo(): La función debe simular 1 sola vez la finalización del torneo y retornar un dataframe con los puntajes finales.

Asumiendo en la simulación que para una victoria siempre tendremos un marcador (1-0), para un empate tendremos un marcador (0-0) y para un partido perdido un resultado (0-1), realice una simulación de los partidos faltantes para la finalización del torneo.

Usando al menos 10000 réplicas de simulación responda las siguientes preguntas: ¿Cuál es la probabilidad de que la selección Colombia clasifique directamente al mundial? (Almacenar valor en `ans.pIIa`) ¿Cuál es la probabilidad de que la selección Colombia vaya a repechaje internacional? (Almacenar valor en `ans.pIIb`) ¿Cuál es la probabilidad de que la selección Colombia quede por fuera del mundial?(Almacenar valor en `ans.pIIc`)

_Escriba el análisis para su solución aquí, reemplazando este texto_

```{r}
## Agregue su solución en R. No olvide agregar comentarios

inicializar_simulacion <- function() {
    return(read.csv("puntajes.csv"))
}

extraer_partidos <- function() {
    return(read.csv("partidos.csv"))
}

extraer_ELO <- function() {
    return(read.csv("ELOconmebol.csv"))
}

prob_partido <- function(ELOlocal, ELOvisitante) {
    # Definimos el valor de dr, que en este caso haciendo
    # referencia al local, sería
    dr <- ELOlocal - ELOvisitante

    # A partir de las formulas dadas, usamos las siguiente ecuaciones
    pEmp <- (2 / (exp(1) * sqrt(2 * pi))) * exp((-(dr / 200)**2) / (exp(2) / 2))
    pVic <- (1 / (1 + 10**(-dr / 400))) - (pEmp / 2)
    pPer <- (1 / (1 + 10**(dr / 400))) - (pEmp / 2)

    # retornamos los valores de probabilidad
    return(c(pEmp, pVic, pPer))
}

simular_partido <- function(ELOlocal, ELOvisitante) {

    # Calculamos la probabilidades dados los ELOs de entrada
    probs <- prob_partido(ELOlocal, ELOvisitante)

    # Y usamos sample para poder realizar la simulación del partido
    res <- sample(c("E", "W", "L"), 1, prob = c(probs[1], probs[2], probs[3]))

    # retornamos el resultado del partido
    return(res)
}

simular_torneo <- function() {

    # Ahora, para poder simular el torneo, debemos primero cargar
    # los datos de cada uno de los .csv
    # Puntajes
    punt <- inicializar_simulacion()

    # Partidos restantes
    part <- extraer_partidos()

    # Y los ELO de todos los equipos
    elos <- extraer_ELO()

    for (i in 1:nrow(part)) {
        eloLoc <- elos[which(elos$Equipo == part[i, 2]), ]
        eloVis <- elos[which(elos$Equipo == part[i, 3]), ]

        res <- simular_partido(eloLoc[, 2], eloVis[, 2])

        if (res == "W") {
            p <- punt[which(punt$pais == eloLoc[, 1]), 2]
            punt[which(punt$pais == eloLoc[, 1]), 2] <- p + 3
        } else if (res == "L") {
            p <- punt[which(punt$pais == eloVis[, 1]), 2]
            punt[which(punt$pais == eloVis[, 1]), 2] <- p + 3
        } else if (res == "E") {
            p1 <- punt[which(punt$pais == eloLoc[, 1]), 2]
            p2 <- punt[which(punt$pais == eloVis[, 1]), 2]
            punt[which(punt$pais == eloLoc[, 1]), 2] <- p1 + 1
            punt[which(punt$pais == eloVis[, 1]), 2] <- p2 + 1
        }
    }

    finalResults <- punt[order(-punt$puntaje), ]

    if ("Colombia" %in% finalResults[1:4, 1]) {
        return(2)
    } else if ("Colombia" == finalResults[5, 1]) {
        return(1)
    } else {
        return(0)
    }
}
```

Corremos la simulación 10000 veces.

```{r}
n <- 10000

pasaDirecto <- 0
pasaRepechaje <- 0
F <- 0

for (i in 1:n) {
    res <- simular_torneo()
    if (res == 2) {
        pasaDirecto <- pasaDirecto + 1
    } else if (res == 1) {
        pasaRepechaje <- pasaRepechaje + 1
    } else if (res == 0) {
        F <- F + 1
    }
}
```

```{r, echo=FALSE}
cat("Probabilidad de pasar: ", pasaDirecto / n)
cat("Probabilidad de repechaje: ", pasaRepechaje / n)
cat("Probabilidad de no pasar: ", F / n)
```

```{r, echo = FALSE}
ans.PIIa <- pasaDirecto / n
ans.PIIb <- pasaRepechaje / n
ans.PIIc <- F / n
```

```
. = ottr::check("tests/p2.R")
```